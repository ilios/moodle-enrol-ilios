{"version":3,"file":"main.min.js","sources":["../src/main.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n//\n\n/**\n * Attaches event handlers for dynamic data loading to dropdown-selects in the new instance form.\n *\n * @module enrol_ilios/main\n * @copyright The Regents of the University of California\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Url from 'core/url';\nimport Notification from 'core/notification';\n\n/**\n * Load initial state.\n *\n * @param {string} courseId The enrollment target course ID.\n */\nexport const init = (courseId) => {\n\n    /**\n     * Path to the callback script.\n     * @type {string}\n     */\n    const CALLBACK_SCRIPT = '/enrol/ilios/ajax.php';\n\n    /**\n     * The ID of the usertype dropdown.\n     * @type {string}\n     */\n    const USERTYPE_FORMFIELD_ID = 'id_selectusertype';\n\n    /**\n     * The names of the dropdown selectors in this form.\n     * They are listed in hierarchical order, which is relevant for cascading state management.\n     * @type {String[]}\n     */\n    const SELECTORS = [\n        'selectschool',\n        'selectprogram',\n        'selectcohort',\n        'selectlearnergroup',\n        'selectsubgroup',\n    ];\n\n    /**\n     * Returns the HTML Dropdown element for a given selector name.\n     * @param {String} selector The selector name.\n     * @returns {HTMLSelectElement} The HTML select element.\n     */\n    const getElementForSelector = function(selector) {\n        return document.getElementById(`id_${selector}`);\n    };\n\n    /**\n     * Returns the name of the callback action for a given selector.\n     * @param {String} selector The selector name.\n     * @returns {String} The name of the callback action.\n     */\n    const getActionForSelector = function(selector) {\n        // Construct and return the action name based on the dropdown element's name for the given selector.\n        const name = getElementForSelector(selector).name;\n        return `get${name}options`;\n    };\n\n    /**\n     * Returns a list of sub-selectors for a given selector.\n     * @param {String} selector The selector name.\n     * @returns {String[]} The list of sub-selector names.\n     */\n    const getSubSelectors = function(selector) {\n        // Since the selectors array is hierarchical in nature, we can just grab and return a sub-list\n        // containing all selector names following the given one.\n        return SELECTORS.slice(SELECTORS.indexOf(selector) + 1);\n    };\n\n    /**\n     * Resets and locks the dropdown for a given selector.\n     * @param {String} selector The selector name.\n     */\n    const resetSelector = function(selector) {\n        // Get the dropdown element for the given selector.\n        const element = getElementForSelector(selector);\n        // Reset the dropdown value to the first option.\n        element.selectedIndex = 0;\n        // Lock the dropdown.\n        element.disabled = true;\n        // Remove all options from the dropdown element.\n        const options = element.querySelectorAll('option:not(:first-child)');\n        options.forEach((option) => option.remove());\n    };\n\n    /**\n     * Resets and locks the dropdowns for a given list of selectors.\n     * @param {String[]} selectors A list of selector names.\n     */\n    const resetSelectors = function(selectors) {\n        selectors.forEach((selector) => resetSelector(selector));\n    };\n\n    /**\n     * Appends the given options to the given selector's dropdown element as HTML elements.\n     * @param {String} selector The selector name.\n     * @param {Object} options A map of key/value pairs.\n     */\n    const populateSelector = function(selector, options) {\n        const element = getElementForSelector(selector);\n        for (let key in options) {\n            const option = new Option(options[key], key);\n            element.appendChild(option);\n        }\n    };\n\n    /**\n     * Retrieves the value of the user type dropdown.\n     * @returns {String} The selected user type.\n     */\n    const getUserType = function() {\n        return document.getElementById(USERTYPE_FORMFIELD_ID).value;\n    };\n\n    /**\n     * Creates a full URL to the callback script with given parameters.\n     * @param {String} id The course ID.\n     * @param {String} action The name of the server-side callback action.\n     * @param {String} filterid The given value to filter on.\n     * @param {String} usertype The given user type value.\n     * @returns {String} The generated callback URL.\n     */\n\n    const buildCallbackUrl = function(id, action, filterid, usertype) {\n        return Url.relativeUrl(CALLBACK_SCRIPT, {id, action, filterid, usertype}, true);\n    };\n\n    /**\n     * Registers the on-change handler on the dropdown corresponding to the given selector.\n     * @param {String} selector The selector name.\n     */\n    const registerSelectorChangeHandler = function(selector) {\n        const subSelectors = getSubSelectors(selector);\n        // If there are no sub-selectors for the given selector, then we're already done here.\n        if (!subSelectors.length) {\n             return;\n        }\n        const nextSelector = subSelectors[0];\n        const element = getElementForSelector(selector);\n        const action = getActionForSelector(nextSelector);\n        element.addEventListener('change', async(e) => {\n            // Reset and lock all sub-selectors of the given selector.\n            resetSelectors(subSelectors);\n            const value = e.currentTarget.value;\n\n            // The values in the dropdowns are themselves encoded \"id:name\" pairs.\n            // Only the default/blank first option does not adhere to this pattern.\n            // We only make a XHR callback if the user selected a non-blank option from the given dropdown.\n            if (-1 === value.indexOf(':')) {\n                return;\n            }\n            const filter = value.split(':')[0];\n            // Get the currently selected user type.\n            const userType = getUserType();\n            // Build the callback URL.\n            const url = buildCallbackUrl(courseId, action, filter, userType);\n            // Fetch data from the callback script and populate the dropdown for the next selector with it.\n            try {\n                const response = await fetch(url);\n                if (!response.ok) {\n                    throw new Error(`Request failed with response status: ${response.status}`);\n                }\n                const json = await response.json();\n                populateSelector(nextSelector, json.response);\n                // Finally, re-enable the next selector.\n                getElementForSelector(nextSelector).disabled = false;\n            } catch (error) {\n                await Notification.exception(error);\n            }\n        });\n    };\n\n    // Wire up the event handlers to the selector elements.\n    SELECTORS.forEach((selector) => {\n        registerSelectorChangeHandler(selector);\n    });\n};\n"],"names":["courseId","SELECTORS","getElementForSelector","selector","document","getElementById","resetSelectors","selectors","forEach","element","selectedIndex","disabled","querySelectorAll","option","remove","resetSelector","registerSelectorChangeHandler","subSelectors","slice","indexOf","getSubSelectors","length","nextSelector","action","name","getActionForSelector","addEventListener","async","value","e","currentTarget","filter","split","userType","url","id","filterid","usertype","Url","relativeUrl","buildCallbackUrl","response","fetch","ok","Error","status","json","options","key","Option","appendChild","populateSelector","error","Notification","exception"],"mappings":";;;;;;;sLA+BqBA,iBAmBXC,UAAY,CACd,eACA,gBACA,eACA,qBACA,kBAQEC,sBAAwB,SAASC,iBAC5BC,SAASC,4BAAqBF,YA6CnCG,eAAiB,SAASC,WAC5BA,UAAUC,SAASL,UAjBD,SAASA,gBAErBM,QAAUP,sBAAsBC,UAEtCM,QAAQC,cAAgB,EAExBD,QAAQE,UAAW,EAEHF,QAAQG,iBAAiB,4BACjCJ,SAASK,QAAWA,OAAOC,WAQHC,CAAcZ,aAyC5Ca,8BAAgC,SAASb,gBACrCc,aArEc,SAASd,iBAGtBF,UAAUiB,MAAMjB,UAAUkB,QAAQhB,UAAY,GAkEhCiB,CAAgBjB,cAEhCc,aAAaI,oBAGZC,aAAeL,aAAa,GAC5BR,QAAUP,sBAAsBC,UAChCoB,OAvFmB,SAASpB,gBAE5BqB,KAAOtB,sBAAsBC,UAAUqB,wBAChCA,gBAoFEC,CAAqBH,cACpCb,QAAQiB,iBAAiB,UAAUC,MAAAA,IAE/BrB,eAAeW,oBACTW,MAAQC,EAAEC,cAAcF,UAKzB,IAAMA,MAAMT,QAAQ,kBAGnBY,OAASH,MAAMI,MAAM,KAAK,GAE1BC,SA1CH7B,SAASC,eAxFU,qBAwF4BuB,MA4C5CM,IAhCW,SAASC,GAAIZ,OAAQa,SAAUC,iBAC7CC,aAAIC,YA3GS,wBA2GoB,CAACJ,GAAAA,GAAIZ,OAAAA,OAAQa,SAAAA,SAAUC,SAAAA,WAAW,GA+B1DG,CAAiBxC,SAAUuB,OAAQQ,OAAQE,oBAG7CQ,eAAiBC,MAAMR,SACxBO,SAASE,SACJ,IAAIC,qDAA8CH,SAASI,eAE/DC,WAAaL,SAASK,QAhEf,SAAS3C,SAAU4C,eAClCtC,QAAUP,sBAAsBC,cACjC,IAAI6C,OAAOD,QAAS,OACflC,OAAS,IAAIoC,OAAOF,QAAQC,KAAMA,KACxCvC,QAAQyC,YAAYrC,SA6DhBsC,CAAiB7B,aAAcwB,KAAKL,UAEpCvC,sBAAsBoB,cAAcX,UAAW,EACjD,MAAOyC,aACCC,sBAAaC,UAAUF,YAMzCnD,UAAUO,SAASL,WACfa,8BAA8Bb"}